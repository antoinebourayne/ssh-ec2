#!/usr/bin/env bash
# This create a ephemeral AWS EC2 instance to execute an SSH script.
# The script synchronize the current working directory before execute the SSH.
# After the SSH session, the data will be resynchronized back, and
# the instance can be leave, stop or destroy.
# The selected region MUST have a key with username, and the AWS user MUST have the privilege
# to create and destroy some instances.
# TODO: install jq (sudo apt-get install jq)

# Author: Philippe PRADOS (ppr at octo.com)

# Usage:
# ./ssh-ec2 [-lsrda|--leave|--stop|--terminate|--detach|--attach] [--no-rsync] [--quiet] [-i <pem file>] [-[LR] port:host:port] [cmds*]
# --terminate : create and start EC2, launch a command in ssh session, and remove EC2 instance and all datas after the end of ssh session.
# --stop      : create and start EC2, launch a command in ssh session, and stop EC2 instance after the end of ssh session.
# --leave     : create and start EC2, launch a command in ssh session, and leave EC2 instance alive
# --detach    : create and start EC2, launch a command in ssh session, detach the session, and leave EC2 instance alive
# --no-rsync  : Never synchronize files
# --quiet     : Silent when rsync files
# --no-quiet  : Print synchronized files when rsync

# Samples:
# ./ssh-ec2 --terminate "source activate cntk_p36 ; make train" # Return when finished
# ./ssh-ec2 --detach    "source activate cntk_p36 ; make train" # Return immediately, then
# ./ssh-ec2 --detach    "while sleep 1; do echo thinking; done"

# Environment:
# - USER              : tag will be created with username
# - TRIGRAM           : user trigram (optional)
# - AWS_PEM           : PEM file path to connect to AWS with SSH
#                       or add your key with ssh-add ~/.ssh/id_rsa
#                       or use -i pemfile.pem in command line (optional if the key was added with ssh-add)
# - AWS_KEY_NAME      : Pair key name in AWS. default $USER
# - AWS_IMAGE_NAME    : Name of image. Default: "Deep Learning AMI (Ubuntu) Version *"
# - AWS_IMAGE_ID      : ami-image. Default: Search with $AWS_IMAGE_NAME
# - AWS_INSTANCE_TYPE : Instance type (default: p2.xlarge)
# - AWS_REGION        : Region (default: $AWS_DEFAULT_REGION or eu-central-1)
# - AWS_NAME_INSTANCE : Name of the AWS EC2 instance. Default: $AWS_KEY_NAME-<current working directory>-$AWS_KEY_NAME
# - AWS_RSYNC_DIR     : Target directory in AWS EC2 instance. Default: basename of current directory
# - AWS_INSTANCE_USER : default user name in image (default:Calculate with the AWS_IMAGE_NAME)
# - AWS_FINAL_STATE   : Final state. Must be leave, destroy or stop. Default: destroy
# - MULTIPLEX         : tmux (default) or screen or empty (setmuxe http://hyperpolyglot.org/multiplexers)
# If the AWS_FINAL_STATE is leave, a screen is detached in the remote device.
# You can reattach with `./ssh-ec2 -a`

# File
# - .rsyncignore      : list of directories to ignore when synchronize files with rsync

shopt -s extglob

if  [[ "$(which aws)" == ""  ]]; then
    echo "ERROR: Install AWS CLI before use ssh-ec2 (https://tinyurl.com/yd4ru2nu)" >&2
    exit 1
fi

if  [[ "$(which jq)" == ""  ]]; then
    echo "ERROR: Install jq before use ssh-ec2" >&2
    exit 1
fi

_DEFAULT_FINAL_STATE=terminate
_DEFAULT_REGION=eu-central-1
_DEFAULT_INSTANCE_TYPE=p2.xlarge
_DEFAULT_MULTIPLEX=tmux
_DEFAULT_IMAGE_NAME="Deep Learning AMI (Ubuntu)*"
#_DEFAULT_IMAGE_NAME="Deep Learning AMI (Amazon Linux)*"  # FIXME
_DEFAULT_IAM_INSTANCE_PROFILE="S3FullAccessRoleForEC2"
_DEFAULT_QUIET=--quiet

nb_of_instance=$(ps aux | grep '[s]sh-ec2' | wc -l )
declare -A TAGS # The user can set somme additional tags
QUIET=${_DEFAULT_QUIET}
while true; do
    case "$1" in
      -l|--leave)
        AWS_FINAL_STATE=leave
        shift
        ;;
      -s|--stop)
        AWS_FINAL_STATE=stop
        shift
        ;;
      -t|--terminate)
        AWS_FINAL_STATE=terminate
        shift
        ;;
      -d|--detach)
        AWS_FINAL_STATE=leave
        SSH_DETACH=y
        shift
        ;;
      -L)
        SSH_PARAMS="${SSH_PARAMS} -L $2"
        shift 2
        ;;
      -R)
        SSH_PARAMS="${SSH_PARAMS} -R $2"
        shift 2
        ;;
      -i)
        PEM_SSH=-i $2
        shift 2
        ;;
      --no-rsync) # TODO: no-rsync-in and no-rsync-out
        NO_RSYNC=y
        shift
        ;;
      --quiet)
        QUIET=--quiet
        shift
        ;;
      --no-quiet)
        QUIET=
        shift
        ;;
      --help)
        echo "ssh-ec2 [-lsrda|--leave|--stop|--terminate|--detach] [--no-rsync] [-i <pem file>] [-[LR] port:host:port] [cmds*]"
        exit 0
        ;;
      -*)
        echo "unknown parameter $1"
        exit 1
        ;;
      * )
        break
        ;;
  esac
done
shopt -s nocasematch

DEBUG=y
if [[ "${DEBUG}" == y ]]; then
  #MULTIPLEX=tmux
  #AWS_DRY= --dryrun
  AWS_INSTANCE_TYPE=t2.small
  #AWS_INSTANCE_TYPE=t2.medium
  #AWS_IMAGE_NAME="Amazon Linux AMI*"

  if [[ -z "$AWS_FINAL_STATE" ]]; then
    AWS_FINAL_STATE=leave
  fi
  NO_RSYNC=y
fi

CWBD=$(basename "$(pwd)")
AWS_KEY_NAME=${AWS_KEY_NAME=${USER}}
if [[ -z "${TRIGRAM}" ]] ; then
  PREFIX=${AWS_KEY_NAME}
else
  PREFIX=${TRIGRAM}
fi
if [[ -z "${AWS_NAME_INSTANCE}" ]] ; then
  AWS_NAME_INSTANCE=${PREFIX}-${CWBD}
fi

AWS_NAME_INSTANCE=${AWS_NAME_INSTANCE=${AWS_NAME_INSTANCE}}
AWS_RSYNC_DIR=${AWS_RSYNC_DIR=${CWBD}}
AWS_IAM_INSTANCE_PROFILE=${AWS_IAM_INSTANCE_PROFILE=${_DEFAULT_IAM_INSTANCE_PROFILE}}
if [[ ! -z "${AWS_IAM_INSTANCE_PROFILE}" ]] ; then
    AWS_IAM_INSTANCE_PROFILE="--iam-instance-profile Name=${AWS_IAM_INSTANCE_PROFILE}"
else
    AWS_IAM_INSTANCE_PROFILE=""
fi
if [ -e ~/.aws/config ];  then
    default_region=$(cat ~/.aws/config | grep region | cut -d '=' -f 2)
else
    default_region=${_DEFAULT_REGION}
fi
AWS_REGION=$(echo ${AWS_DEFAULT_REGION=${default_region}} | tr -d '[:space:]')

AWS_IMAGE_NAME=${AWS_IMAGE_NAME=${_DEFAULT_IMAGE_NAME}}
AWS_LAST_KNOW_IMAGE_ID=$(aws --region ${AWS_REGION} ec2 describe-images \
  --filters "Name=name,Values=${AWS_IMAGE_NAME}"  \
  --output json | jq -r '.Images | sort_by(.CreationDate) | last(.[]).ImageId')
AWS_IMAGE_ID=${AWS_IMAGE_ID=${AWS_LAST_KNOW_IMAGE_ID}}
check=${AWS_IMAGE_ID?Image not found in the region ${AWS_REGION}}

# Try to find the default username
# See https://alestic.com/2014/01/ec2-ssh-username/
declare -A _default_user
_default_user["Amazon Linux"]="ec2-user"
_default_user["ubuntu"]="ubuntu"
_default_user["RHEL 6.[0-3]"]="root"
_default_user["RHEL 6.[0-9]+"]="ec2-user"
_default_user["Fedora"]="fedora"
_default_user["Centos"]="centos"
_default_user["SUSE"]="ec2-user"
_default_user["BitNami"]="bitnami"
_default_user["TurnKey"]="root"
_default_user["NanoStack"]="ubuntu"
_default_user["FreeBSD"]="ec2-user"
_default_user["OmniOS"]="root"

if [[ -z "${AWS_INSTANCE_USER}" ]]; then
    for K in "${!_default_user[@]}"; do
        if [[ "${AWS_IMAGE_NAME}" =~ "${K}" ]] ; then
            AWS_INSTANCE_USER=${_default_user[${K}]}
            break
        fi
    done
fi

if [[ "${AWS_IMAGE_NAME}" =~ "ubuntu" ]] ; then
AWS_INSTANCE_USER=${AWS_INSTANCE_USER=ubuntu}
elif [[ "${AWS_IMAGE_NAME}" =~ "Amazon Linux" ]] ; then
AWS_INSTANCE_USER=${AWS_INSTANCE_USER=ubuntu}
fi

AWS_INSTANCE_TYPE=${AWS_INSTANCE_TYPE=${_DEFAULT_INSTANCE_TYPE}}

MULTIPLEX=${MULTIPLEX=${_DEFAULT_MULTIPLEX}}

declare -A TAGS
TAGS["Name"]="${AWS_NAME_INSTANCE}"
TAGS["User"]="${USER}"
TAGS["Hostname"]="$(hostname)"
if [ ! -z "${TRIGRAM}" ] ; then
  TAGS["Trigram"]="${TRIGRAM}"
fi


_TAGS="["
__tags=""
for K in "${!TAGS[@]}"; do
  _TAGS="${_TAGS}{Key=${K},Value=${TAGS[${K}]}},"
  __tags="${__tags}${K}=${TAGS[${K}]}, "
done
_TAGS=${_TAGS%*,}"]"
__tags=${__tags%*, }

AWS_TAGS="ResourceType=instance,Tags=$_TAGS"
AWS_FINAL_STATE=${AWS_FINAL_STATE=${_DEFAULT_FINAL_STATE}}
AWS_USER_DATA=${AWS_USER_DATA="sudo locale-gen $(locale | grep LANG= | cut -d '=' -f 2)"}
AWS_DISABLE_HOST_CHECKING="-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o LogLevel=quiet"


if [[ ! -z "${AWS_PEM}" ]]; then
PEM_SSH="-i ${AWS_PEM}"
fi

echo "----------------------------------------------------------"
echo "EC2 Name: ${AWS_NAME_INSTANCE}"
echo "Region:   ${AWS_REGION}"
echo "Type:     ${AWS_INSTANCE_TYPE}"
echo "Image Id: ${AWS_IMAGE_ID} (${AWS_IMAGE_NAME})"
echo "Key name: ${AWS_KEY_NAME}"
echo "Tags:     ${__tags}"
echo "----------------------------------------------------------"

trap_with_arg() {
    func="$1" ; shift
    for sig ; do
        trap "$func $sig" "$sig"
    done
}

function finish() {
    trap - EXIT
    trap_with_arg exit INT

    # Check last instance
    nb_of_instance=$(ps aux | grep '[s]sh-ec2' | wc -l )

    # Only the last instance of ssh manage the final state
    if [[ "${nb_of_instance}" < 3 ]] ; then
        # Stop the instance
        case "${AWS_FINAL_STATE}" in
            stop)
              echo -e "\e[33mStop instance...\e[0m \c"
              aws --region ${AWS_REGION} ec2 stop-instances --instance-ids ${AWS_INSTANCE_ID} ${AWS_DRY} --output text ${AWS_DRY} > /dev/null
              if [[ -z "${AWS_DRY}" ]]; then
                  while STATE=$(aws --region ${AWS_REGION} ec2 describe-instances \
                      --instance-ids $AWS_INSTANCE_ID \
                      --output text \
                      --query 'Reservations[*].Instances[*].State.Name');
                    test "$STATE" != "stopped" -a "$STATE" != "terminated"; do
                    sleep 3;
                  done;
                  echo -e "\e[33mdone\e[0m"
              fi
              ;;
            terminate)
                echo -e "\e[32mTerminate instance... \e[0m\c"
                aws --region ${AWS_REGION} ec2 terminate-instances --instance-ids ${AWS_INSTANCE_ID} ${AWS_DRY} --output text ${AWS_DRY} > /dev/null
                while STATE=$(aws --region ${AWS_REGION} ec2 describe-instances \
                    --instance-ids $AWS_INSTANCE_ID \
                    --output text \
                    --query 'Reservations[*].Instances[*].State.Name');
                  test "$STATE" != "terminated"; do
                  sleep 3;
                done;
                echo -e "\e[32mand security group... \e[0m\c"
                aws --region ${AWS_REGION} ec2 delete-security-group --group-name ${AWS_NAME_INSTANCE}
                echo -e "\e[32mdone\e[0m"
                ;;
            *)
                if [[ $nb_of_instance > 2 ]] ; then
                    AWS_FINAL_STATE=leave
                    echo -e "\e[91mWARNING: Another connexion to EC2 instance is alive. The AWS EC instance is active\e[0m"
                else
                    echo -e "\e[91mWARNING: The AWS EC instance ${AWS_NAME_INSTANCE} is alive\e[0m" >&2
                fi
                ;;
        esac
    fi
    if [ ! "$1" == "EXIT" ] ; then
        exit -1 ;
    fi
}

trap_with_arg finish EXIT

# Search instance
AWS_INSTANCE_ID=$(aws --region ${AWS_REGION} ec2 describe-instances \
  --filters "Name=tag:Name,Values=${AWS_NAME_INSTANCE}" \
    "Name=instance-state-name,Values=pending,running,stopping,stopped" \
   --query 'Reservations[*].Instances[*].InstanceId' --output text)

if [[ -z "$AWS_INSTANCE_ID" ]]; then
    echo ""
    # Create instance
    AWS_SECURITY_GROUP_ID=$(aws --region ${AWS_REGION} ec2 describe-security-groups \
      --group-names ppr-tensorflow \
      --query 'SecurityGroups[*].GroupId' \
      --output text 2>/dev/null)
    if [[ -z "${AWS_SECURITY_GROUP_ID}" ]]; then
        echo -e "Creating new AWS EC2 security group... \c"
        AWS_SECURITY_GROUP_ID=$(aws --region ${AWS_REGION} ec2 create-security-group \
          --group-name ${AWS_NAME_INSTANCE} \
          --description "Security group for ${AWS_NAME_INSTANCE}" \
          ${AWS_DRY} \
          --output text 2>/dev/null)
        echo -e "with port 22 open... \c"
       aws --region ${AWS_REGION} ec2 authorize-security-group-ingress \
          --group-name ${AWS_NAME_INSTANCE} \
          --protocol tcp --port 22 \
          --cidr 0.0.0.0/0 \
          ${AWS_DRY} >/dev/null  2>&1
        echo -e "done"
    fi

    echo -e "Creating new AWS EC2 instance... \c"
    case "${AWS_FINAL_STATE}" in
        leave|terminate)
            shutdown_mode=terminate
            ;;
        stop)
            shutdown_mode=stop
            ;;
    esac

    AWS_INSTANCE_ID=$(aws --region ${AWS_REGION} ec2 run-instances \
      --region ${AWS_REGION}  \
      --instance-type ${AWS_INSTANCE_TYPE} \
      ${AWS_IAM_INSTANCE_PROFILE} \
      --security-groups ${AWS_NAME_INSTANCE} \
      --tag-specifications "${AWS_TAGS}" \
      --image-id ${AWS_IMAGE_ID} \
      --key-name ${AWS_KEY_NAME} \
      --instance-initiated-shutdown-behavior ${shutdown_mode} \
      --user-data "${AWS_USER_DATA}" \
      --output text --query 'Instances[*].InstanceId')

    echo -e "starting... \c"
    aws --region ${AWS_REGION} ec2 wait instance-status-ok --instance-ids ${AWS_INSTANCE_ID}
    echo -e "done"
fi
STATE=$(aws --region ${AWS_REGION} ec2 describe-instances --instance-ids $AWS_INSTANCE_ID --output text --query 'Reservations[*].Instances[*].State.Name')
if [ "$STATE" == "stopping" -o "$STATE" == "stopped" ]; then
    echo ""
    echo -e "Start instance... \c"
      while STATE=$(aws --region ${AWS_REGION} ec2 describe-instances \
          --instance-ids $AWS_INSTANCE_ID \
          --output text \
          --query 'Reservations[*].Instances[*].State.Name');
        test "$STATE" != "stopped"; do
        sleep 3;
      done;
    aws --region ${AWS_REGION} ec2 start-instances --instance-ids $AWS_INSTANCE_ID ${AWS_DRY} >/dev/null
    aws --region ${AWS_REGION} ec2 wait instance-running --instance-ids ${AWS_INSTANCE_ID}
    echo -e "done"
fi

# Synchronize files with the new instance
aws --region ${AWS_REGION} ec2 wait instance-running --instance-ids ${AWS_INSTANCE_ID}
AWS_HOST=${AWS_INSTANCE_USER}@$(aws --region ${AWS_REGION} ec2 describe-instances \
  --instance-ids $AWS_INSTANCE_ID \
  --output text \
  --query 'Reservations[*].Instances[*].NetworkInterfaces[*].Association.PublicIp')

if [[ "$nb_of_instance" < 3 && -z "${NO_RSYNC}" ]] ; then
    echo -e "Synchronizes current directory (except files in .rsyncignore)... \c"
#    rsync -vz \
#      -e "ssh ${PEM_SSH} ${AWS_DISABLE_HOST_CHECKING} -o LogLevel=quiet" \
#      ./ ${AWS_HOST}:~/${AWS_RSYNC_DIR} \
#      --exclude-from .rsyncignore \
#      --archive \
#      --modify-window=1 \
#      --update \
#      ${QUIET} \
#      --copy-links
    sed -E 's/^(.*)/ --exclude '\''\1'\''/' .rsyncignore | xargs rsync -vz \
      -e "ssh ${PEM_SSH} ${AWS_DISABLE_HOST_CHECKING} -o LogLevel=quiet" \
      ./ ${AWS_HOST}:~/${AWS_RSYNC_DIR} \
      --archive \
      --modify-window=1 \
      --update \
      ${QUIET} \
      --copy-links
    echo -e "done"
fi

_CD="[ -e \"${AWS_RSYNC_DIR}\" ] && cd \"${AWS_RSYNC_DIR}\""
_CMD="$*"

case "${MULTIPLEX}" in
    screen)
        _TERM=-t
        if [[ "$SSH_DETACH" == y ]]; then
            _CMD="${_CD} ; screen -dmS ${AWS_NAME_INSTANCE} '$_CMD'"
        else
            if [ -z "$_CMD" ] ; then
                _TERM=-t
                _CMD="${_CD} ; screen -rS ${AWS_NAME_INSTANCE} || screen -S ${AWS_NAME_INSTANCE}"
            else
                _TERM=-t
                _CMD="${_CD} ; screen -S ${AWS_NAME_INSTANCE} $SHELL -c '$_CMD'"
            fi
        fi
        ;;
    tmux)
        _TERM=-t
        # ./ssh-ec2 --detach 'for ((;;)); do echo "break"; sleep 2; done'
        if [[ "$SSH_DETACH" == y ]]; then
            _CMD="${_CD} ; tmux new-session -s ${AWS_NAME_INSTANCE} -d '$_CMD'"
        else
            #_CMD="tmux new-session -s ${AWS_NAME_INSTANCE} '$_CMD""'"
            if [ -z "$_CMD" ] ; then
              _TERM=-t
              _CMD="${_CD} ; tmux a -t ${AWS_NAME_INSTANCE} || tmux new-session -s ${AWS_NAME_INSTANCE} "
            else
                _TERM=-t
                _CMD="${_CD} ; tmux new-session -s ${AWS_NAME_INSTANCE} '$_CMD'"
            fi
        fi
        ;;
      *)
        if [[ "$SSH_DETACH" == y ]]; then
            echo "ERROR: Impossible to detach session without MULTIPLEX" >&2
            exit 1
        else
          _TERM=-t
          if [ -z "$_CMD" ] ; then
            _CMD="${_CD} ; exec \$SHELL"
          else
            _TERM=-t
            _CMD="${_CD} ; ${_CMD}"
          fi
        fi
        ;;
esac

( set -x; ssh ${PEM_SSH} ${AWS_HOST} ${AWS_DISABLE_HOST_CHECKING} ${_TERM} ${SSH_PARAMS} "${_CMD}" )
# Refresh nb_of_instance
nb_of_instance=$(ps aux | grep '[s]sh-ec2' | wc -l )

# Reverce synchronisation
if [[ "$nb_of_instance" < 3 && -z "${NO_RSYNC}" ]] ; then
    echo -e "Synchronizes result... \c"
    sed -E 's/^(.*)/ --exclude '\''\1'\''/' .rsyncignore | xargs rsync -vza \
      -e "ssh ${PEM_SSH} -o StrictHostKeyChecking=no -o LogLevel=quiet" \
      ${AWS_HOST}:~/${AWS_RSYNC_DIR}/ ./ \
      --quiet \
      --update \
      $([ "$AWS_DRY" != "" ] && echo "-n" ) \
      --ignore-times
    echo -e "done"
fi
exit 0
